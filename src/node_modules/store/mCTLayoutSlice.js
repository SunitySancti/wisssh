import { createSlice, current } from '@reduxjs/toolkit'

import { styleVars } from 'containers/MultiColumnTapeLayout'

const multiColumnTapeLayoutSlice = createSlice({
    name: 'mCTLayout',
    initialState: {
        columns: [],
        columnsQtyLimit: 0,
        columnWidth: 0,
        items: [],
        itemsRenderList: [],
    },
    reducers: {
        clearItems(state) {
            state.items = [];
        },
        putItems(state, { payload }) {
            state.items = [];
            state.items.push(...payload);
        },
        fillRenderList(state) {
            state.itemsRenderList = [];
            state.itemsRenderList.push(...current(state).items);
        },
        takeItemToRender(state) {
            const columnHeights = [...document.querySelectorAll('.mct-column')]?.map(col => col.clientHeight);
            const shortestColumnId = columnHeights.indexOf(Math.min(...columnHeights));

            if (shortestColumnId === -1 || !current(state).itemsRenderList.length) return state;

            state.columns[ shortestColumnId ]?.push( state.itemsRenderList.shift() );
        },
        setColumnsQtyLimitAndWidth(state) {
            const layoutWidth = document.querySelector('.mct-layout')?.clientWidth;
            const { outerSpacing, innerSpacing, columnMinWidth } = styleVars;
            
            const columnsQtyLimit = Math.floor((layoutWidth - 2 * outerSpacing + innerSpacing) / (columnMinWidth + innerSpacing));
            
            state.columnsQtyLimit = columnsQtyLimit;
        },
        setColumnWidth(state) {
            const { outerSpacing, innerSpacing, columnMaxWidth } = styleVars;
            const layoutWidth = document.querySelector('.mct-layout')?.clientWidth;
            const realColumnsQty = current(state).columns.length;
            const isAllSpaceCoveredByColumns = (realColumnsQty * (columnMaxWidth + innerSpacing) - innerSpacing) >= layoutWidth;

            const columnLengths = current(state).columns.map(column => column.length);
            const isItemsWrapped = columnLengths.filter(length => length > 1).length > 0;
            
            const columnWidth = isAllSpaceCoveredByColumns || isItemsWrapped
                              ? Math.round(((layoutWidth - 2 * outerSpacing + innerSpacing) / realColumnsQty) - innerSpacing)
                              : columnMaxWidth;

            document.querySelectorAll('.mct-column')?.forEach(column => {
                const value = isItemsWrapped
                            ? '' : `${columnMaxWidth}px`;
                column.style.maxWidth = value
            });

            state.columnWidth = columnWidth;
        },
        resetColumns(state) {
            const columnsQtyLimit = current(state).columnsQtyLimit;
            state.columns = [];
            for (let i=0; i<columnsQtyLimit && current(state).itemsRenderList.length; i++) {
                state.columns.push( [state.itemsRenderList.shift()] );
            }
        },
    }
})

export const {
    clearItems,
    putItems,
    fillRenderList,
    takeItemToRender,
    setColumnsQtyLimitAndWidth,
    setColumnWidth,
    resetColumns,
} = multiColumnTapeLayoutSlice.actions;

export default multiColumnTapeLayoutSlice.reducer;